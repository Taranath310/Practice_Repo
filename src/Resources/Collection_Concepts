collection I
List I
	If we want the element in the order of insertion
	If we want allow the duplicates
	Classes
		ArrayList
		LinkedList
		Vector
set I
    If we don't want the order of insertion
	If we want the element in the sorted order
	If we don't want allow the duplicates
	Classes
		HashSet
		LinkedHashSet
queue I
	If we want FIFO concept
	Classes
		Priority Queue



Map I
	when we want to store the data in form of key and value
	here keys are unique but not the value
	Classes
		HashMap
		LinkedHashMap
		HashTable


    ArrayList
        1.default size will be 10 and if we add one more element it will grow
        2.when we want to retrieve the element frequently then we need to go for this ArrayList
        3.when we have more insertion and deletion is there at this time ArrayList will move all the elements to right it will take time
        4.Methods
            	1. add(Object o)
            	2. add(Index i,Object o)
            	3. addAll(Collection c)
            	4. addAll(Index i,Collection c)
            	5. remove(Index i)
            	6. remove(Object o)
            	7. removeAll(Collection c)
            	8. retainAll(Collection c)
            	9. get(Index i)
            	10.set(Index i,Object o)
            	11.contains(Object o)
            	12.containsAll(Collection c)
            	13.isEmpty()
            	14.size()
            	15.toArray(Collection c)


Note: collections is a class which is having some predefined methods like
        1. Collections.reverse(Collection c)
        2. Collections.sort(Collection c)
        3. Collections.sort(Collection c,Collections.reverseOrder())
        3. Collections.min(Collection c)
        4. Collections.max(Collection c)
        5. Collections.shuffle(Collection c)

Note: converting array to arrayList
        String[] arrayData={"Bangalore","Mysore","Tumkur"};
        ArrayList al=new ArrayList(Arrays.asList(arrayData));

    LinkedList [FILO]
        1. when we want to insert and delete the elements then we go for LinkedList
        2. retrieving the element is difficult here as it is storing the memory address of previous element in it
        3. All the above methods with the following
            a. addFirst(Object o)
            b. addLast(Object o)
            c. removeFirst(Object o)
            d. removeLast(object o)
            e. getFirst()
            f. getLast()



    HashSet [default size is 16]
        1. insertion order is not maintained
        2. duplicates are not allowed
        3. it will insert the data using hashcode tech
        4. store heterogeneous data
        5. null can be stored
        6. if we have more search then we need to go for HashSet

    Note: we have something called load factor i.e., 0.75
          [whenever the elements are getting stored in HashSet and if it is closes to 75% it will create new HashSet and move all the elements to it]

          we can define our own load factor as HashSet hs=new HashSet(100,(float)0.95);


    LinkedHashSet
        1. Order is preserved here
        2. all the concepts same as above


    Queue I
        When we want to insert or represent the elements which are prior to processing
        Queue will follow FIFO
        All the elements will be stored in Tail and it will get removed in Head


                             LinkedList C    Priority Queue C
            Insertion order   Maintained      Maintained
            Duplicates         Allowed          Allowed
            HeterogeneousData  Allowed        not allowed


            1. add() //we can use it for adding the element or adding the object, if this is successful it will return true and if not it will return exceptions
            2. offer() //we can use it for adding the element or adding the object, if this is successful it will return true and if not it will return false

            3. element() // we can use it for getting the first element in the queue, if it is not having any element it will return exception
            4. Peek() // we can use it for getting the first element in the queue, if it is not having any element it will return null

            5. remove() //we can use it for returning the element and then remove from Queue, if queue is empty it will return exception.
            6. pool() //we can use it for returning the element and then remove from Queue, if queue is empty it will return null.